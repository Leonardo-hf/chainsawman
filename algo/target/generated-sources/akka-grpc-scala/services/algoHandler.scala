
// Generated by Akka gRPC. DO NOT EDIT.
package services

import scala.concurrent.ExecutionContext

import akka.grpc.scaladsl.{ GrpcExceptionHandler, GrpcMarshalling }
import akka.grpc.Trailers

import akka.actor.ActorSystem
import akka.actor.ClassicActorSystemProvider
import akka.annotation.ApiMayChange
import akka.http.scaladsl.model
import akka.stream.SystemMaterializer

import akka.grpc.internal.TelemetryExtension

import akka.grpc.AkkaGrpcGenerated




/*
 * Generated by Akka gRPC. DO NOT EDIT.
 *
 * The API of this class may still change in future Akka gRPC versions, see for instance
 * https://github.com/akka/akka-grpc/issues/994
 */
@ApiMayChange
@AkkaGrpcGenerated
object algoHandler {
    private val notFound = scala.concurrent.Future.successful(model.HttpResponse(model.StatusCodes.NotFound))
    private val unsupportedMediaType = scala.concurrent.Future.successful(model.HttpResponse(model.StatusCodes.UnsupportedMediaType))

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `algoHandler.partial` when combining
     * several services.
     */
    def apply(implementation: algo)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
      partial(implementation).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `algoHandler.partial` when combining
     * several services.
     */
    def apply(implementation: algo, eHandler: ActorSystem => PartialFunction[Throwable, Trailers])(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
      partial(implementation, algo.name, eHandler).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `algoHandler.partial` when combining
     * several services.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def apply(implementation: algo, prefix: String)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
      partial(implementation, prefix).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `algoHandler.partial` when combining
     * several services.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def apply(implementation: algo, prefix: String, eHandler: ActorSystem => PartialFunction[Throwable, Trailers])(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
      partial(implementation, prefix, eHandler).orElse { case _ => notFound }



    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler. The generated handler falls back to a reflection handler for
     * `algo` and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `algoHandler.partial` when combining
     * several services.
     */
    def withServerReflection(implementation: algo)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
        akka.grpc.scaladsl.ServiceHandler.concatOrNotFound(
          algoHandler.partial(implementation),
          akka.grpc.scaladsl.ServerReflection.partial(List(algo)))


    /**
     * Creates a partial `HttpRequest` to `HttpResponse` handler that can be combined with handlers of other
     * services with `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` and then used in for example
     * `Http().bindAndHandleAsync`.
     *
     * Use `algoHandler.apply` if the server is only handling one service.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def partial(implementation: algo, prefix: String = algo.name, eHandler: ActorSystem => PartialFunction[Throwable, Trailers] = GrpcExceptionHandler.defaultMapper)(implicit system: ClassicActorSystemProvider): PartialFunction[model.HttpRequest, scala.concurrent.Future[model.HttpResponse]] = {
      implicit val mat = SystemMaterializer(system).materializer
      implicit val ec: ExecutionContext = mat.executionContext
      val spi = TelemetryExtension(system).spi

      import algo.Serializers._

      def handle(request: model.HttpRequest, method: String): scala.concurrent.Future[model.HttpResponse] =
        GrpcMarshalling.negotiated(request, (reader, writer) =>
          (method match {
            
            case "createAlgo" =>
                
                GrpcMarshalling.unmarshal(request.entity)(CreateAlgoReqSerializer, mat, reader)
                  .flatMap(implementation.createAlgo(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(AlgoReplySerializer, writer, system))
            
            case "queryAlgo" =>
                
                GrpcMarshalling.unmarshal(request.entity)(EmptySerializer, mat, reader)
                  .flatMap(implementation.queryAlgo(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(AlgoReplySerializer, writer, system))
            
            case "dropAlgo" =>
                
                GrpcMarshalling.unmarshal(request.entity)(DropAlgoReqSerializer, mat, reader)
                  .flatMap(implementation.dropAlgo(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(AlgoReplySerializer, writer, system))
            
            case "degree" =>
                
                GrpcMarshalling.unmarshal(request.entity)(BaseReqSerializer, mat, reader)
                  .flatMap(implementation.degree(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(RankReplySerializer, writer, system))
            
            case "pagerank" =>
                
                GrpcMarshalling.unmarshal(request.entity)(BaseReqSerializer, mat, reader)
                  .flatMap(implementation.pagerank(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(RankReplySerializer, writer, system))
            
            case "louvain" =>
                
                GrpcMarshalling.unmarshal(request.entity)(BaseReqSerializer, mat, reader)
                  .flatMap(implementation.louvain(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(ClusterReplySerializer, writer, system))
            
            case "shortestPath" =>
                
                GrpcMarshalling.unmarshal(request.entity)(ShortestPathReqSerializer, mat, reader)
                  .flatMap(implementation.shortestPath(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(ClusterReplySerializer, writer, system))
            
            case "avgShortestPath" =>
                
                GrpcMarshalling.unmarshal(request.entity)(BaseReqSerializer, mat, reader)
                  .flatMap(implementation.avgShortestPath(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(MetricsReplySerializer, writer, system))
            
            case "avgClustering" =>
                
                GrpcMarshalling.unmarshal(request.entity)(BaseReqSerializer, mat, reader)
                  .flatMap(implementation.avgClustering(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(MetricsReplySerializer, writer, system))
            
            case "custom" =>
                
                GrpcMarshalling.unmarshal(request.entity)(CustomAlgoReqSerializer, mat, reader)
                  .flatMap(implementation.custom(_))
                  .map(e => GrpcMarshalling.marshal(e, eHandler)(CustomAlgoReplySerializer, writer, system))
            
            case m => scala.concurrent.Future.failed(new NotImplementedError(s"Not implemented: $m"))
          })
          .recoverWith(GrpcExceptionHandler.from(eHandler(system.classicSystem))(system, writer))
      ).getOrElse(unsupportedMediaType)

      Function.unlift((req: model.HttpRequest) => req.uri.path match {
        case model.Uri.Path.Slash(model.Uri.Path.Segment(`prefix`, model.Uri.Path.Slash(model.Uri.Path.Segment(method, model.Uri.Path.Empty)))) =>
          Some(handle(spi.onRequest(prefix, method, req), method))
        case _ =>
          None
      })
    }
  }

